{"componentChunkName":"component---src-templates-blog-js","path":"/blogs/wpf","result":{"data":{"markdownRemark":{"html":"<p>Windows Presentation Foundation (or WPF) is a graphical subsystem by Microsoft for rendering user interfaces in Windows-based applications. In my coding career I worked with this technology. This page provides a mini project that has a few comprehensive examples of what WPF is capable of. The last topic of this page talks about Model-View-ViewModel (MMVV), which is a software architectural patttern that decouples the user interface with the business logic. This page is not meant to be a tutorial but simply a refresher to those that have experiences with WPF and MVVM.</p>\n<p>This project demostrates a few WPF features through a series of examples. The first example is on animation. Here I have two images, one is a normal picture of me and the another one is not so skinny picture of me. These two images are overlapped with each other using the Canvas tag. In WPF, every control can only have one child, thus containers like StackPanel, WrapPanel, and DockPanel are used to lay out the interface, howevever they are \"stacked\" relative to each other except for the canvas and grid containers. Only Grid and Canvas allow for overlapping. Here we use a trigger with a loaded event to begin an animation that changes the opacity of a target with the name \"pic\" (which in this case is the not skinny picture) from fully visible to invisible within two seconds. The \"RepeatBehavior\" is set to forever which means the animation loops infinitely. Furthermore, we have two more routed events for mouse in and out which pauses and resumes the storyboard, respectively.</p>\n<pre><code>&#x3C;Canvas>\n    &#x3C;Canvas.Triggers>\n        &#x3C;EventTrigger RoutedEvent=\"Canvas.Loaded\">\n            &#x3C;BeginStoryboard x:Name=\"OpacityStoryboard\">\n                &#x3C;Storyboard TargetName=\"pic2\" TargetProperty=\"Opacity\">\n                    &#x3C;DoubleAnimation From=\"1\" To=\"0\" Duration=\"0:0:2\" AutoReverse=\"True\" RepeatBehavior=\"Forever\" />\n                &#x3C;/Storyboard>\n            &#x3C;/BeginStoryboard>\n        &#x3C;/EventTrigger>\n\n        &#x3C;EventTrigger RoutedEvent=\"UIElement.MouseEnter\">\n            &#x3C;PauseStoryboard BeginStoryboardName=\"OpacityStoryboard\" />\n        &#x3C;/EventTrigger>\n        &#x3C;EventTrigger RoutedEvent=\"UIElement.MouseLeave\">\n            &#x3C;ResumeStoryboard BeginStoryboardName=\"OpacityStoryboard\" />\n        &#x3C;/EventTrigger>\n    &#x3C;/Canvas.Triggers>\n\n    &#x3C;Image x:Name=\"pic1\" Source=\"Images/Skinny.jpg\" />\n    &#x3C;Image x:Name=\"pic2\" Source=\"Images/NotSkinny.jpg\" />\n&#x3C;/Canvas>\n</code></pre>\n<p>In this demo, we observe some pretty amazing WPF styling. The first style targets the whole Window. It has a trigger that listens to the binding of the property \"IsChecked\" of the element by the name of \"redColorCheckBox.\" If this value is true, then it sets the background to red. But what background? The background of the specific type, which in this case is the window. The second block of code is inside the Window.Resources which means any styling or defines in this block is applied to the whole window. The first style in here applies to every button, hence in the video clip on the left you see that the three buttons all look the same (height of 30px, height of 80px, font size of 12px, etc). Furthermore, once again we have a trigger and this one is \"IsMouseOver\", meaning whenever the mouse is over the control (button), the foreground turns red. Styles in WPF do not have to be defined under Resources, it can be defined straight within the scope of the individual control. If you look at the second textbox, you will see that I am manipulating the \"Background\" and \"IsEnabled\" properties. The background is binded to whatever value I type in the textbox. This is done through RelativeSource to myself and taking the text property. Similarly, I have a data trigger that compares to my typed text, if it is equal to the string \"disabled\" then it will set the \"IsEnabled\" property to false. As you can see, the possibilities of WPF styling is endless. The complete code snippet is below.</p>\n<pre><code>&#x3C;Window.Style>\n\t&#x3C;Style TargetType=\"{x:Type Window}\">\n\t\t&#x3C;Style.Triggers>\n\t\t\t&#x3C;DataTrigger Binding=\"{Binding ElementName=redColorCheckBox, Path=IsChecked}\" Value=\"True\">\n\t\t\t\t&#x3C;Setter Property=\"Background\" Value=\"Red\" />\n\t\t\t&#x3C;/DataTrigger>\n\t\t&#x3C;/Style.Triggers>\n\t&#x3C;/Style>\n&#x3C;/Window.Style>\n\n&#x3C;Window.Resources>\n\t&#x3C;Style TargetType = \"{x:Type Button}\">\n\t\t&#x3C;Setter Property = \"Height\" Value = \"30\" />\n\t\t&#x3C;Setter Property = \"Width\" Value = \"80\" />\n\t\t&#x3C;Setter Property = \"Foreground\" Value = \"Blue\" />\n\t\t&#x3C;Setter Property = \"FontSize\" Value = \"12\" />\n\t\t&#x3C;Setter Property = \"Margin\" Value = \"10\" />\n\t\t&#x3C;Style.Triggers>\n\t\t\t&#x3C;Trigger Property=\"IsMouseOver\" Value=\"True\">\n\t\t\t\t&#x3C;Setter Property=\"Foreground\" Value=\"red\" />\n\t\t\t&#x3C;/Trigger>\n\t\t&#x3C;/Style.Triggers>\n\t&#x3C;/Style>\n\n\t&#x3C;Style x:Key=\"practiceStyle\" TargetType=\"{x:Type TextBox}\" >\n\t\t&#x3C;Style.Triggers>\n\t\t\t&#x3C;MultiTrigger>\n\t\t\t\t&#x3C;MultiTrigger.Conditions>\n\t\t\t\t\t&#x3C;Condition Property=\"IsMouseOver\" Value=\"True\" />\n\t\t\t\t\t&#x3C;Condition Property=\"IsKeyboardFocused\"  Value=\"True\" />\n\t\t\t\t&#x3C;/MultiTrigger.Conditions>\n\t\t\t\t&#x3C;MultiTrigger.Setters>\n\t\t\t\t\t&#x3C;Setter Property=\"Foreground\" Value=\"red\" />\n\t\t\t\t\t&#x3C;Setter Property=\"FontWeight\" Value=\"Bold\" />\n\t\t\t\t\t&#x3C;Setter Property=\"FontSize\" Value=\"18\" />\n\t\t\t\t&#x3C;/MultiTrigger.Setters>\n\t\t\t&#x3C;/MultiTrigger>\n\t\t&#x3C;/Style.Triggers>\n\t&#x3C;/Style>\n\n\t&#x3C;SolidColorBrush x:Key=\"staticBrush\" Color=\"Yellow\" />\n&#x3C;/Window.Resources>\n\n&#x3C;StackPanel HorizontalAlignment=\"Center\">\n\t&#x3C;Button Content = \"Button1\"/>\n\t&#x3C;Button Content = \"Button2\"/>\n\t&#x3C;Button Content = \"Button3\"/>\n\n\t&#x3C;TextBox Width=\"150\" Background=\"{StaticResource staticBrush}\" Style=\"{StaticResource practiceStyle}\" />\n\n\t&#x3C;TextBox Width=\"100\" Margin=\"10\">\n\t\t&#x3C;TextBox.Style>\n\t\t\t&#x3C;Style TargetType=\"TextBox\">\n\t\t\t\t&#x3C;Style.Triggers>\n\t\t\t\t\t&#x3C;DataTrigger Binding=\"{Binding RelativeSource={RelativeSource Self}, Path=Text}\" Value=\"disabled\">\n\t\t\t\t\t\t&#x3C;Setter Property=\"IsEnabled\" Value=\"False\" />\n\t\t\t\t\t&#x3C;/DataTrigger>\n\t\t\t\t&#x3C;/Style.Triggers>\n\n\t\t\t\t&#x3C;Setter Property=\"Background\" Value=\"{Binding RelativeSource={RelativeSource Self}, Path=Text}\" />\n\t\t\t&#x3C;/Style>\n\t\t&#x3C;/TextBox.Style>\n\t&#x3C;/TextBox>\n\n\t&#x3C;CheckBox x:Name = \"redColorCheckBox\" Content = \"Set red as foreground color\" Margin = \"10\"/>\n&#x3C;/StackPanel>\n</code></pre>\n<p>Data binding is what makes WPF so powerful. In this demo, we will see how to properly create a data template. The XAML is pretty straight forward, we have a listbox and a button. This button subscribes to a click event which we will discuss later. The listbox contains an ItemsSource that populates the collection as well as an Item Template. The StaticResource of this property points to a data template that \"customizes\" the appearance on how to display the data, which in this sense I assign it to have a grid inside a border and in this grid we get and set the name and age of a person. Note that the binding of \"Name\" and \"Age\" are actually properties of an instance of the datum (from the item source). As for the population of the items and the model itself, I handled them in the code behind. I have a class called Person that has name and age as attributes and publicly expose them so the data template can retrieve them. In the constructor I have a list of people and assign it to the item source of the listbox. Note that we can also use the .NET ObservableCollection which implements the INotifyCollectionChanged that works well with MVVM. When users change the name and age of each item, the properties automatically get updated because of the binding, and when they click on the button, there's a message box that shows the person's information.</p>\n<pre><code>&#x3C;Window.Resources>\n\t&#x3C;DataTemplate x:Key =\"template\">\n\t\t&#x3C;Border x:Name=\"bord3r\" BorderBrush=\"Red\" BorderThickness=\"1\">\n\t\t\t&#x3C;Grid>\n\t\t\t\t&#x3C;Grid.RowDefinitions>\n\t\t\t\t\t&#x3C;RowDefinition Height = \"Auto\" />\n\t\t\t\t\t&#x3C;RowDefinition Height = \"Auto\" />\n\t\t\t\t&#x3C;/Grid.RowDefinitions>\n\t\t\t\t&#x3C;Grid.ColumnDefinitions>\n\t\t\t\t\t&#x3C;ColumnDefinition Width = \"Auto\" />\n\t\t\t\t\t&#x3C;ColumnDefinition Width = \"200\" />\n\t\t\t\t&#x3C;/Grid.ColumnDefinitions>\n\n\t\t\t\t&#x3C;Label Margin = \"10\" Content=\"Name\"/>\n\t\t\t\t&#x3C;TextBox Grid.Column = \"1\" Margin = \"10\" Text = \"{Binding Name}\" />\n\t\t\t\t&#x3C;Label Margin = \"10\" Grid.Row = \"1\" Content=\"Age\"/>\n\t\t\t\t&#x3C;TextBox Grid.Column = \"1\" Grid.Row = \"1\" Margin = \"10\" Text = \"{Binding Age}\" />\n\t\t\t&#x3C;/Grid>\n\t\t&#x3C;/Border>\n\n\t\t&#x3C;DataTemplate.Triggers>\n\t\t\t&#x3C;DataTrigger Binding=\"{Binding Path=Name}\" Value=\"Yvonne\">\n\t\t\t\t&#x3C;Setter TargetName=\"bord3r\" Property=\"BorderBrush\" Value=\"blue\" />\n\t\t\t&#x3C;/DataTrigger>\n\t\t&#x3C;/DataTemplate.Triggers>\n\t&#x3C;/DataTemplate>\n&#x3C;/Window.Resources>\n\n&#x3C;Grid>\n\t&#x3C;Grid.RowDefinitions>\n\t\t&#x3C;RowDefinition Height = \"Auto\" />\n\t\t&#x3C;RowDefinition Height = \"*\" />\n\t&#x3C;/Grid.RowDefinitions>\n\n\t&#x3C;ListBox x:Name=\"listbox\" ItemsSource = \"{Binding Source}\" ItemTemplate=\"{StaticResource template}\" />\n\n\t&#x3C;Button Grid.Row = \"1\"  Content = \"_Show...\" Click = \"Button_Click\" Width = \"80\" HorizontalAlignment = \"Left\" Margin = \"10\"/>\n\n&#x3C;/Grid>\n</code></pre>\n<pre><code>public partial class DataTemplateExample : Window\n{\n    public DataTemplateExample()\n    {\n        InitializeComponent();\n\n        List people = new List();\n        people.Add(new Person { Name = \"Ethan\", Age = 27 });\n        people.Add(new Person { Name = \"Yvonne\", Age = 62 });\n        people.Add(new Person { Name = \"Thomas\", Age = 12 });\n\n        listbox.ItemsSource = people;\n    }\n\n    private void Button_Click(object sender, RoutedEventArgs e)\n    {\n        Person selectedPerson = (Person)listbox.SelectedValue;\n\n        if (selectedPerson != null)\n        {\n            string message = string.Format(\"{0} is {1} years old\", selectedPerson.Name, selectedPerson.Age);\n            MessageBox.Show(message);\n        }\n    }\n}\n\npublic class Person\n{\n    private string _Name;\n    private double _Age;\n\n    public string Name\n    {\n        get { return _Name; }\n        set { _Name = value; }\n    }\n\n    public double Age\n    {\n        get { return _Age; }\n        set { _Age = value; }\n    }\n}\n</code></pre>\n<p>This is an example of a very basic and classic MVVM pattern. The main idea of MVVM is that the Model should know nothing about the View and vice-versa. The Model is defined as any object that holds information. The View is the front end presentational layer. The \"link\" between the two is the ViewModel. The ViewModel should only know about the Model and not the View, and the View should only know about the ViewModel and not the Model.</p>\n<p>This example is very simple, we have a listbox, data grid, and combo box that shares the same items source. There is a button that upon invoke will take a textbox string and adds to the collection. The core of MVVM lies in the implementation of the INotifyPropertyChanged interface. This interface allows any messages to be updated back to the View. Any property in the ViewModel that is bound to the View should implement this.</p>\n<pre><code>public class ViewModelBase: INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    protected virtual void OnPropertyChanged(string propertyName)\n    {\n        PropertyChangedEventHandler handler = PropertyChanged;\n        if (handler != null)\n        {\n            handler(this, new PropertyChangedEventArgs(propertyName));\n        }\n    }\n}\n</code></pre>\n<p>The second main component is the implementation of the ICommand interface. This is to bind commands in the View such as button or any control event.</p>\n<pre><code>public class DelegateCommand : ICommand\n{\n    private readonly Action _execute;\n    private readonly Func _canExecute;\n\n    public DelegateCommand(Action executeMethod)\n        : this(executeMethod, null)\n    {\n    }\n\n    public DelegateCommand(Action executeMethod, Func canExecuteMethod)\n    {\n        if (executeMethod == null)\n            throw new ArgumentNullException(\"executeMethod\");\n\n        _execute = executeMethod;\n        _canExecute = canExecuteMethod;\n    }\n\n    public void Execute(object parameter)\n    {\n        _execute();\n    }\n\n    public bool CanExecute(object parameter)\n    {\n        return _canExecute == null ? true : _canExecute();\n    }\n\n    public event EventHandler CanExecuteChanged\n    {\n        add { CommandManager.RequerySuggested += value; }\n        remove { CommandManager.RequerySuggested -= value; }\n    }\n}\n</code></pre>\n<p>The model can be anything, here I choose to create a blueprint of a person that has a first name, last name, and age.</p>\n<pre><code>public class Person : INotifyPropertyChanged\n{\n    private string _FirstName;\n    private string _LastName;\n    private int _Age;\n\n    public string FirstName\n    {\n        get { return _FirstName; }\n        set\n        {\n            if (_FirstName != value)\n            {\n                _FirstName = value;\n                OnPropertyChanged(\"FirstName\");\n            }\n        }\n    }\n\n    public string LastName\n    {\n        get { return _LastName;}\n        set\n        {\n            if (_LastName != value)\n            {\n                _LastName = value;\n                OnPropertyChanged(\"LastName\");\n            }\n        }\n    }\n\n    public int Age\n    {\n        get { return _Age;}\n        set\n        {\n            if (_Age != value)\n            {\n                _Age = value;\n                OnPropertyChanged(\"Age\");\n            }\n        }\n    }\n\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    protected virtual void OnPropertyChanged(string propertyName)\n    {\n        PropertyChangedEventHandler handler = PropertyChanged;\n        if (handler != null)\n        {\n            handler(this, new PropertyChangedEventArgs(propertyName));\n        }\n    }\n}\n</code></pre>\n<p>I daresay the ViewModel is the most complex part of the application. Afterall, it handles all the business logic and serves as the mediator between the Model and View. Here, we populate the collection in the constructor and listen to the change in selected person. Because the list box, data grid, and combo box all shared the same ObservableCollection and because we notify the same messages back to the view, all three get updated at the same time.</p>\n<pre><code>public class MainWindowViewModel : ViewModelBase\n{\n    public DelegateCommand AddUserCommand { get; set; }\n    public ObservableCollection People { get; set; }\n    private Person _SelectedPerson;\n\n    private string _SelectedItemString;\n    public string TextProperty { get; set; }\n\n    public MainWindowViewModel()\n    {\n        AddUserCommand = new DelegateCommand(OnAddUserCommand);\n\n        People = new ObservableCollection\n        {\n            new Person { FirstName=\"Ethan\", LastName=\"Uong\", Age=32 },\n            new Person { FirstName=\"Yvonne\", LastName=\"Liu\", Age=26 },\n            new Person { FirstName=\"Happy\", LastName=\"Doggy\", Age=3 },\n        };\n    }\n\n    public Person SelectedPerson\n    {\n        get { return _SelectedPerson; }\n        set\n        {\n            if (_SelectedPerson != value &#x26;&#x26; value != null)\n            {\n                _SelectedPerson = value;\n                SelectedItemString = value.FirstName;\n                OnPropertyChanged(\"SelectedPerson\");\n            }\n        }\n    }\n\n    public string SelectedItemString\n    {\n        get { return _SelectedItemString; }\n        set\n        {\n            if (_SelectedItemString != value)\n            {\n                _SelectedItemString = value;\n                OnPropertyChanged(\"SelectedItemString\");\n            }\n        }\n    }\n\n    private void OnAddUserCommand()\n    {\n        if (!string.IsNullOrEmpty(TextProperty))\n        {\n            People.Add(new Person {\n                FirstName = TextProperty.ToString(),\n                LastName = TextProperty.ToString(),\n                Age = DateTime.Now.Second\n            });\n        }\n    }\n}\n</code></pre>\n<p>And finally we have the View. The last major concept is how exactlyl do we bind everything together? We have established that the View must know nothing about the Model, but how precisely does the View understand the ViewModel? This is done by setting the DataContext of the View to an instance of the ViewModel.</p>\n<pre><code>&#x3C;Grid Margin=\"20\">\n    &#x3C;Grid.RowDefinitions>\n        &#x3C;RowDefinition Height=\"Auto\"/>\n        &#x3C;RowDefinition Height=\"Auto\"/>\n    &#x3C;/Grid.RowDefinitions>\n\n    &#x3C;StackPanel Grid.Row=\"0\">\n        &#x3C;StackPanel Orientation=\"Horizontal\">\n            &#x3C;ListBox ItemsSource=\"{Binding People}\" SelectedItem=\"{Binding SelectedPerson}\"\n                     DisplayMemberPath=\"FirstName\" HorizontalAlignment=\"Left\"/>\n            &#x3C;DataGrid ItemsSource=\"{Binding People}\" SelectedItem=\"{Binding SelectedPerson}\" CanUserAddRows=\"False\"\n                      HorizontalAlignment=\"Left\" Margin=\"5,0,0,0\"/>\n            &#x3C;ComboBox ItemsSource=\"{Binding People}\" SelectedItem=\"{Binding SelectedPerson}\"\n                      DisplayMemberPath=\"FirstName\" Margin=\"5,0,0,5\" VerticalAlignment=\"Top\"/>\n        &#x3C;/StackPanel>\n\n        &#x3C;TextBlock FontWeight=\"Bold\" Margin=\"5\" Text=\"The selected person is \">\n        &#x3C;Run Text=\"{Binding SelectedItemString}\"/>&#x3C;/TextBlock>\n        &#x3C;Label Content=\"Type in a name and hit button to add to collection\" />\n    &#x3C;/StackPanel>\n\n    &#x3C;StackPanel Grid.Row=\"1\" Width=\"150\" HorizontalAlignment=\"Left\">\n        &#x3C;TextBox Text=\"{Binding TextProperty}\" Margin=\"5\"/>\n        &#x3C;Button Content=\"Add person\" Command=\"{Binding AddUserCommand}\" Margin=\"5\" />\n    &#x3C;/StackPanel>\n&#x3C;/Grid>\n</code></pre>","frontmatter":{"stack":".NET, C#, WPF, MVVM","title":"Windows Presentation Foundation","featuredImg":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#082868","images":{"fallback":{"src":"/gatsby-blogging/static/71dca21933dc69d0a392e89c94f7ec4b/e6e83/wpf.jpg","srcSet":"/gatsby-blogging/static/71dca21933dc69d0a392e89c94f7ec4b/28b3a/wpf.jpg 366w,\n/gatsby-blogging/static/71dca21933dc69d0a392e89c94f7ec4b/5258c/wpf.jpg 731w,\n/gatsby-blogging/static/71dca21933dc69d0a392e89c94f7ec4b/e6e83/wpf.jpg 1462w","sizes":"(min-width: 1462px) 1462px, 100vw"},"sources":[{"srcSet":"/gatsby-blogging/static/71dca21933dc69d0a392e89c94f7ec4b/240c8/wpf.webp 366w,\n/gatsby-blogging/static/71dca21933dc69d0a392e89c94f7ec4b/395d5/wpf.webp 731w,\n/gatsby-blogging/static/71dca21933dc69d0a392e89c94f7ec4b/cfa0d/wpf.webp 1462w","type":"image/webp","sizes":"(min-width: 1462px) 1462px, 100vw"}]},"width":1462,"height":900}}}}}},"pageContext":{"slug":"wpf"}},"staticQueryHashes":["1240161400","362580002"]}